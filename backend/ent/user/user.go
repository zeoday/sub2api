// Code generated by ent, DO NOT EDIT.

package user

import (
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
)

const (
	// Label holds the string label denoting the user type in the database.
	Label = "user"
	// FieldID holds the string denoting the id field in the database.
	FieldID = "id"
	// FieldCreatedAt holds the string denoting the created_at field in the database.
	FieldCreatedAt = "created_at"
	// FieldUpdatedAt holds the string denoting the updated_at field in the database.
	FieldUpdatedAt = "updated_at"
	// FieldDeletedAt holds the string denoting the deleted_at field in the database.
	FieldDeletedAt = "deleted_at"
	// FieldEmail holds the string denoting the email field in the database.
	FieldEmail = "email"
	// FieldPasswordHash holds the string denoting the password_hash field in the database.
	FieldPasswordHash = "password_hash"
	// FieldRole holds the string denoting the role field in the database.
	FieldRole = "role"
	// FieldBalance holds the string denoting the balance field in the database.
	FieldBalance = "balance"
	// FieldConcurrency holds the string denoting the concurrency field in the database.
	FieldConcurrency = "concurrency"
	// FieldStatus holds the string denoting the status field in the database.
	FieldStatus = "status"
	// FieldUsername holds the string denoting the username field in the database.
	FieldUsername = "username"
	// FieldNotes holds the string denoting the notes field in the database.
	FieldNotes = "notes"
	// FieldTotpSecretEncrypted holds the string denoting the totp_secret_encrypted field in the database.
	FieldTotpSecretEncrypted = "totp_secret_encrypted"
	// FieldTotpEnabled holds the string denoting the totp_enabled field in the database.
	FieldTotpEnabled = "totp_enabled"
	// FieldTotpEnabledAt holds the string denoting the totp_enabled_at field in the database.
	FieldTotpEnabledAt = "totp_enabled_at"
	// EdgeAPIKeys holds the string denoting the api_keys edge name in mutations.
	EdgeAPIKeys = "api_keys"
	// EdgeRedeemCodes holds the string denoting the redeem_codes edge name in mutations.
	EdgeRedeemCodes = "redeem_codes"
	// EdgeSubscriptions holds the string denoting the subscriptions edge name in mutations.
	EdgeSubscriptions = "subscriptions"
	// EdgeAssignedSubscriptions holds the string denoting the assigned_subscriptions edge name in mutations.
	EdgeAssignedSubscriptions = "assigned_subscriptions"
	// EdgeAnnouncementReads holds the string denoting the announcement_reads edge name in mutations.
	EdgeAnnouncementReads = "announcement_reads"
	// EdgeAllowedGroups holds the string denoting the allowed_groups edge name in mutations.
	EdgeAllowedGroups = "allowed_groups"
	// EdgeUsageLogs holds the string denoting the usage_logs edge name in mutations.
	EdgeUsageLogs = "usage_logs"
	// EdgeAttributeValues holds the string denoting the attribute_values edge name in mutations.
	EdgeAttributeValues = "attribute_values"
	// EdgePromoCodeUsages holds the string denoting the promo_code_usages edge name in mutations.
	EdgePromoCodeUsages = "promo_code_usages"
	// EdgeUserAllowedGroups holds the string denoting the user_allowed_groups edge name in mutations.
	EdgeUserAllowedGroups = "user_allowed_groups"
	// Table holds the table name of the user in the database.
	Table = "users"
	// APIKeysTable is the table that holds the api_keys relation/edge.
	APIKeysTable = "api_keys"
	// APIKeysInverseTable is the table name for the APIKey entity.
	// It exists in this package in order to avoid circular dependency with the "apikey" package.
	APIKeysInverseTable = "api_keys"
	// APIKeysColumn is the table column denoting the api_keys relation/edge.
	APIKeysColumn = "user_id"
	// RedeemCodesTable is the table that holds the redeem_codes relation/edge.
	RedeemCodesTable = "redeem_codes"
	// RedeemCodesInverseTable is the table name for the RedeemCode entity.
	// It exists in this package in order to avoid circular dependency with the "redeemcode" package.
	RedeemCodesInverseTable = "redeem_codes"
	// RedeemCodesColumn is the table column denoting the redeem_codes relation/edge.
	RedeemCodesColumn = "used_by"
	// SubscriptionsTable is the table that holds the subscriptions relation/edge.
	SubscriptionsTable = "user_subscriptions"
	// SubscriptionsInverseTable is the table name for the UserSubscription entity.
	// It exists in this package in order to avoid circular dependency with the "usersubscription" package.
	SubscriptionsInverseTable = "user_subscriptions"
	// SubscriptionsColumn is the table column denoting the subscriptions relation/edge.
	SubscriptionsColumn = "user_id"
	// AssignedSubscriptionsTable is the table that holds the assigned_subscriptions relation/edge.
	AssignedSubscriptionsTable = "user_subscriptions"
	// AssignedSubscriptionsInverseTable is the table name for the UserSubscription entity.
	// It exists in this package in order to avoid circular dependency with the "usersubscription" package.
	AssignedSubscriptionsInverseTable = "user_subscriptions"
	// AssignedSubscriptionsColumn is the table column denoting the assigned_subscriptions relation/edge.
	AssignedSubscriptionsColumn = "assigned_by"
	// AnnouncementReadsTable is the table that holds the announcement_reads relation/edge.
	AnnouncementReadsTable = "announcement_reads"
	// AnnouncementReadsInverseTable is the table name for the AnnouncementRead entity.
	// It exists in this package in order to avoid circular dependency with the "announcementread" package.
	AnnouncementReadsInverseTable = "announcement_reads"
	// AnnouncementReadsColumn is the table column denoting the announcement_reads relation/edge.
	AnnouncementReadsColumn = "user_id"
	// AllowedGroupsTable is the table that holds the allowed_groups relation/edge. The primary key declared below.
	AllowedGroupsTable = "user_allowed_groups"
	// AllowedGroupsInverseTable is the table name for the Group entity.
	// It exists in this package in order to avoid circular dependency with the "group" package.
	AllowedGroupsInverseTable = "groups"
	// UsageLogsTable is the table that holds the usage_logs relation/edge.
	UsageLogsTable = "usage_logs"
	// UsageLogsInverseTable is the table name for the UsageLog entity.
	// It exists in this package in order to avoid circular dependency with the "usagelog" package.
	UsageLogsInverseTable = "usage_logs"
	// UsageLogsColumn is the table column denoting the usage_logs relation/edge.
	UsageLogsColumn = "user_id"
	// AttributeValuesTable is the table that holds the attribute_values relation/edge.
	AttributeValuesTable = "user_attribute_values"
	// AttributeValuesInverseTable is the table name for the UserAttributeValue entity.
	// It exists in this package in order to avoid circular dependency with the "userattributevalue" package.
	AttributeValuesInverseTable = "user_attribute_values"
	// AttributeValuesColumn is the table column denoting the attribute_values relation/edge.
	AttributeValuesColumn = "user_id"
	// PromoCodeUsagesTable is the table that holds the promo_code_usages relation/edge.
	PromoCodeUsagesTable = "promo_code_usages"
	// PromoCodeUsagesInverseTable is the table name for the PromoCodeUsage entity.
	// It exists in this package in order to avoid circular dependency with the "promocodeusage" package.
	PromoCodeUsagesInverseTable = "promo_code_usages"
	// PromoCodeUsagesColumn is the table column denoting the promo_code_usages relation/edge.
	PromoCodeUsagesColumn = "user_id"
	// UserAllowedGroupsTable is the table that holds the user_allowed_groups relation/edge.
	UserAllowedGroupsTable = "user_allowed_groups"
	// UserAllowedGroupsInverseTable is the table name for the UserAllowedGroup entity.
	// It exists in this package in order to avoid circular dependency with the "userallowedgroup" package.
	UserAllowedGroupsInverseTable = "user_allowed_groups"
	// UserAllowedGroupsColumn is the table column denoting the user_allowed_groups relation/edge.
	UserAllowedGroupsColumn = "user_id"
)

// Columns holds all SQL columns for user fields.
var Columns = []string{
	FieldID,
	FieldCreatedAt,
	FieldUpdatedAt,
	FieldDeletedAt,
	FieldEmail,
	FieldPasswordHash,
	FieldRole,
	FieldBalance,
	FieldConcurrency,
	FieldStatus,
	FieldUsername,
	FieldNotes,
	FieldTotpSecretEncrypted,
	FieldTotpEnabled,
	FieldTotpEnabledAt,
}

var (
	// AllowedGroupsPrimaryKey and AllowedGroupsColumn2 are the table columns denoting the
	// primary key for the allowed_groups relation (M2M).
	AllowedGroupsPrimaryKey = []string{"user_id", "group_id"}
)

// ValidColumn reports if the column name is valid (part of the table columns).
func ValidColumn(column string) bool {
	for i := range Columns {
		if column == Columns[i] {
			return true
		}
	}
	return false
}

// Note that the variables below are initialized by the runtime
// package on the initialization of the application. Therefore,
// it should be imported in the main as follows:
//
//	import _ "github.com/Wei-Shaw/sub2api/ent/runtime"
var (
	Hooks        [1]ent.Hook
	Interceptors [1]ent.Interceptor
	// DefaultCreatedAt holds the default value on creation for the "created_at" field.
	DefaultCreatedAt func() time.Time
	// DefaultUpdatedAt holds the default value on creation for the "updated_at" field.
	DefaultUpdatedAt func() time.Time
	// UpdateDefaultUpdatedAt holds the default value on update for the "updated_at" field.
	UpdateDefaultUpdatedAt func() time.Time
	// EmailValidator is a validator for the "email" field. It is called by the builders before save.
	EmailValidator func(string) error
	// PasswordHashValidator is a validator for the "password_hash" field. It is called by the builders before save.
	PasswordHashValidator func(string) error
	// DefaultRole holds the default value on creation for the "role" field.
	DefaultRole string
	// RoleValidator is a validator for the "role" field. It is called by the builders before save.
	RoleValidator func(string) error
	// DefaultBalance holds the default value on creation for the "balance" field.
	DefaultBalance float64
	// DefaultConcurrency holds the default value on creation for the "concurrency" field.
	DefaultConcurrency int
	// DefaultStatus holds the default value on creation for the "status" field.
	DefaultStatus string
	// StatusValidator is a validator for the "status" field. It is called by the builders before save.
	StatusValidator func(string) error
	// DefaultUsername holds the default value on creation for the "username" field.
	DefaultUsername string
	// UsernameValidator is a validator for the "username" field. It is called by the builders before save.
	UsernameValidator func(string) error
	// DefaultNotes holds the default value on creation for the "notes" field.
	DefaultNotes string
	// DefaultTotpEnabled holds the default value on creation for the "totp_enabled" field.
	DefaultTotpEnabled bool
)

// OrderOption defines the ordering options for the User queries.
type OrderOption func(*sql.Selector)

// ByID orders the results by the id field.
func ByID(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldID, opts...).ToFunc()
}

// ByCreatedAt orders the results by the created_at field.
func ByCreatedAt(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldCreatedAt, opts...).ToFunc()
}

// ByUpdatedAt orders the results by the updated_at field.
func ByUpdatedAt(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldUpdatedAt, opts...).ToFunc()
}

// ByDeletedAt orders the results by the deleted_at field.
func ByDeletedAt(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldDeletedAt, opts...).ToFunc()
}

// ByEmail orders the results by the email field.
func ByEmail(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldEmail, opts...).ToFunc()
}

// ByPasswordHash orders the results by the password_hash field.
func ByPasswordHash(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldPasswordHash, opts...).ToFunc()
}

// ByRole orders the results by the role field.
func ByRole(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldRole, opts...).ToFunc()
}

// ByBalance orders the results by the balance field.
func ByBalance(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldBalance, opts...).ToFunc()
}

// ByConcurrency orders the results by the concurrency field.
func ByConcurrency(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldConcurrency, opts...).ToFunc()
}

// ByStatus orders the results by the status field.
func ByStatus(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldStatus, opts...).ToFunc()
}

// ByUsername orders the results by the username field.
func ByUsername(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldUsername, opts...).ToFunc()
}

// ByNotes orders the results by the notes field.
func ByNotes(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldNotes, opts...).ToFunc()
}

// ByTotpSecretEncrypted orders the results by the totp_secret_encrypted field.
func ByTotpSecretEncrypted(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldTotpSecretEncrypted, opts...).ToFunc()
}

// ByTotpEnabled orders the results by the totp_enabled field.
func ByTotpEnabled(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldTotpEnabled, opts...).ToFunc()
}

// ByTotpEnabledAt orders the results by the totp_enabled_at field.
func ByTotpEnabledAt(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldTotpEnabledAt, opts...).ToFunc()
}

// ByAPIKeysCount orders the results by api_keys count.
func ByAPIKeysCount(opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborsCount(s, newAPIKeysStep(), opts...)
	}
}

// ByAPIKeys orders the results by api_keys terms.
func ByAPIKeys(term sql.OrderTerm, terms ...sql.OrderTerm) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newAPIKeysStep(), append([]sql.OrderTerm{term}, terms...)...)
	}
}

// ByRedeemCodesCount orders the results by redeem_codes count.
func ByRedeemCodesCount(opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborsCount(s, newRedeemCodesStep(), opts...)
	}
}

// ByRedeemCodes orders the results by redeem_codes terms.
func ByRedeemCodes(term sql.OrderTerm, terms ...sql.OrderTerm) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newRedeemCodesStep(), append([]sql.OrderTerm{term}, terms...)...)
	}
}

// BySubscriptionsCount orders the results by subscriptions count.
func BySubscriptionsCount(opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborsCount(s, newSubscriptionsStep(), opts...)
	}
}

// BySubscriptions orders the results by subscriptions terms.
func BySubscriptions(term sql.OrderTerm, terms ...sql.OrderTerm) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newSubscriptionsStep(), append([]sql.OrderTerm{term}, terms...)...)
	}
}

// ByAssignedSubscriptionsCount orders the results by assigned_subscriptions count.
func ByAssignedSubscriptionsCount(opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborsCount(s, newAssignedSubscriptionsStep(), opts...)
	}
}

// ByAssignedSubscriptions orders the results by assigned_subscriptions terms.
func ByAssignedSubscriptions(term sql.OrderTerm, terms ...sql.OrderTerm) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newAssignedSubscriptionsStep(), append([]sql.OrderTerm{term}, terms...)...)
	}
}

// ByAnnouncementReadsCount orders the results by announcement_reads count.
func ByAnnouncementReadsCount(opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborsCount(s, newAnnouncementReadsStep(), opts...)
	}
}

// ByAnnouncementReads orders the results by announcement_reads terms.
func ByAnnouncementReads(term sql.OrderTerm, terms ...sql.OrderTerm) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newAnnouncementReadsStep(), append([]sql.OrderTerm{term}, terms...)...)
	}
}

// ByAllowedGroupsCount orders the results by allowed_groups count.
func ByAllowedGroupsCount(opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborsCount(s, newAllowedGroupsStep(), opts...)
	}
}

// ByAllowedGroups orders the results by allowed_groups terms.
func ByAllowedGroups(term sql.OrderTerm, terms ...sql.OrderTerm) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newAllowedGroupsStep(), append([]sql.OrderTerm{term}, terms...)...)
	}
}

// ByUsageLogsCount orders the results by usage_logs count.
func ByUsageLogsCount(opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborsCount(s, newUsageLogsStep(), opts...)
	}
}

// ByUsageLogs orders the results by usage_logs terms.
func ByUsageLogs(term sql.OrderTerm, terms ...sql.OrderTerm) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newUsageLogsStep(), append([]sql.OrderTerm{term}, terms...)...)
	}
}

// ByAttributeValuesCount orders the results by attribute_values count.
func ByAttributeValuesCount(opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborsCount(s, newAttributeValuesStep(), opts...)
	}
}

// ByAttributeValues orders the results by attribute_values terms.
func ByAttributeValues(term sql.OrderTerm, terms ...sql.OrderTerm) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newAttributeValuesStep(), append([]sql.OrderTerm{term}, terms...)...)
	}
}

// ByPromoCodeUsagesCount orders the results by promo_code_usages count.
func ByPromoCodeUsagesCount(opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborsCount(s, newPromoCodeUsagesStep(), opts...)
	}
}

// ByPromoCodeUsages orders the results by promo_code_usages terms.
func ByPromoCodeUsages(term sql.OrderTerm, terms ...sql.OrderTerm) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newPromoCodeUsagesStep(), append([]sql.OrderTerm{term}, terms...)...)
	}
}

// ByUserAllowedGroupsCount orders the results by user_allowed_groups count.
func ByUserAllowedGroupsCount(opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborsCount(s, newUserAllowedGroupsStep(), opts...)
	}
}

// ByUserAllowedGroups orders the results by user_allowed_groups terms.
func ByUserAllowedGroups(term sql.OrderTerm, terms ...sql.OrderTerm) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newUserAllowedGroupsStep(), append([]sql.OrderTerm{term}, terms...)...)
	}
}
func newAPIKeysStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(APIKeysInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.O2M, false, APIKeysTable, APIKeysColumn),
	)
}
func newRedeemCodesStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(RedeemCodesInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.O2M, false, RedeemCodesTable, RedeemCodesColumn),
	)
}
func newSubscriptionsStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(SubscriptionsInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.O2M, false, SubscriptionsTable, SubscriptionsColumn),
	)
}
func newAssignedSubscriptionsStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(AssignedSubscriptionsInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.O2M, false, AssignedSubscriptionsTable, AssignedSubscriptionsColumn),
	)
}
func newAnnouncementReadsStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(AnnouncementReadsInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.O2M, false, AnnouncementReadsTable, AnnouncementReadsColumn),
	)
}
func newAllowedGroupsStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(AllowedGroupsInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.M2M, false, AllowedGroupsTable, AllowedGroupsPrimaryKey...),
	)
}
func newUsageLogsStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(UsageLogsInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.O2M, false, UsageLogsTable, UsageLogsColumn),
	)
}
func newAttributeValuesStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(AttributeValuesInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.O2M, false, AttributeValuesTable, AttributeValuesColumn),
	)
}
func newPromoCodeUsagesStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(PromoCodeUsagesInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.O2M, false, PromoCodeUsagesTable, PromoCodeUsagesColumn),
	)
}
func newUserAllowedGroupsStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(UserAllowedGroupsInverseTable, UserAllowedGroupsColumn),
		sqlgraph.Edge(sqlgraph.O2M, true, UserAllowedGroupsTable, UserAllowedGroupsColumn),
	)
}
